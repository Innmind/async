{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to <code>innmind/async</code>","text":"<p>This package is an abstraction on top of <code>Fiber</code>s to coordinate multiple tasks asynchronously.</p> <p>The goal is to easily move the execution of any code built using <code>innmind/operating-system</code> from a synchronous context to an async one. This means that it's easier to experiment running a piece of code asynchronously and then move back if the experiment is not successful. This also means that you can test each part of an asynchronous system synchronously.</p> Sneak peek <pre><code>use Innmind\\Async\\{\n    Scheduler,\n    Scope\\Continuation,\n};\nuse Innmind\\OperatingSystem\\{\n    OperatingSystem,\n    Factory,\n};\nuse Innmind\\Immutable\\Sequence;\n\nScheduler::of(Factory::build())\n    -&gt;sink(null)\n    -&gt;with(\n        static fn(\n            $_,\n            OperatingSystem $os,\n            Continuation $continuation,\n        ) =&gt; $continuation\n            -&gt;schedule(Sequence::of(\n                static fn(OperatingSystem $os) =&gt; importUsers($os),\n                static fn(OperatingSystem $os) =&gt; importProducts($os),\n            ))\n            -&gt;finish(),\n    );\n</code></pre>"},{"location":"limitations/","title":"Limitations","text":"<p>The limitations mentionned below exists for now as fixing them will take time. But they can be overcome, and will be in due time!</p>"},{"location":"limitations/#http-calls","title":"HTTP calls","text":"<p>Currently HTTP calls are done via <code>curl</code> but it can't be integrated in the same loop as other streams. To allow the coordination of multiple tasks when doing HTTP calls the system use a timeout of <code>10ms</code> and switches between tasks at this max rate.</p> <p>To fix this limitation a new implementation entirely based on PHP streams needs to be created.</p> <p>Meanwhile if your goal is to make multiple concurrent HTTP calls you don't need this package. <code>innmind/http-transport</code> already supports concurrent calls on it's own (without the limitation mentionned above).</p>"},{"location":"limitations/#sql-queries","title":"SQL queries","text":"<p>SQL queries executed via <code>$os-&gt;remote()-&gt;sql()</code> are still executed synchronously (as it uses <code>PDO</code>).</p> <p>To fix this limitation a new implementation entirely based on PHP streams needs to be created.</p>"},{"location":"limitations/#scaling","title":"Scaling","text":"<p>It seems that the current implementation of this package has a limit of around 100K concurrent tasks before it starts slowing down.</p> <p>A simple script scheduling 100k tasks that each halts the process for 10 second will take ~13s.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>composer require innmind/async\n</code></pre>"},{"location":"getting-started/#setup","title":"Setup","text":"async.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nrequire 'path/to/vendor/autoload.php';\n\nuse Innmind\\Async\\{\n    Scheduler,\n    Scope\\Continuation,\n};\nuse Innmind\\OperatingSystem\\{\n    Factory,\n    OperatingSystem,\n};\n\n$os = Factory::build();\nScheduler::of($os)\n    -&gt;sink(null) #(1)\n    -&gt;with(function(\n        $_, #(2)\n        OperatingSystem $os,\n        Continuation $continuation,\n    ): Continuation {\n        // this is the scope that will schedule tasks\n\n        return $continuation;\n    });\n</code></pre> <ol> <li>You'll learn in a later chapter what this value is. For now leave it like this.</li> <li>You'll learn in a later chapter what this value is. For now leave it like this.</li> </ol> <p>You can run this script via <code>php async.php</code> in your terminal. For now it executes an infinite loop that does nothing.</p> <p>You'll see in the next chapter what you can inside the loop.</p>"},{"location":"getting-started/scope/","title":"Create a scope","text":"<p>As mentionned in the preface a Scope is a function. In fact, it can be any <code>callable</code> that accept the following arguments:</p> <ul> <li>a carried value (1)</li> <li>an instance of the operating system</li> <li>a continuation</li> <li>a list of results</li> </ul> <ol> <li>You'll learn in a later chapter how to use this value.</li> </ol> <p>To keep things simple for now, we'll only talk about the second and third arguments. And to feel a bit more at home we'll use a class with the <code>__invoke</code> method instead of an anonymous function.</p> <p>If we re-implement the example from the previous page we get:</p> ScopeScheduler Scope.php<pre><code>use Innmind\\Async\\Scope\\Continuation;\nuse Innmind\\OperatingSystem\\OperatingSystem;\n\nfinal class Scope\n{\n    public function __invoke(\n        mixed $_,\n        OperatingSystem $os,\n        Continuation $continuation,\n    ): Continuation {\n        return $continuation;\n    }\n}\n</code></pre> async.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nrequire 'path/to/vendor/autoload.php';\n\nuse Innmind\\Async\\{\n    Scheduler,\n    Scope\\Continuation,\n};\nuse Innmind\\OperatingSystem\\{\n    Factory,\n    OperatingSystem,\n};\n\n$os = Factory::build();\nScheduler::of($os)\n    -&gt;sink(null)\n    -&gt;with(new Scope);\n</code></pre> <p>Once again, if you run <code>php async.php</code> in your terminal it will execute an infinite loop that does nothing.</p> <p>However by defining the scope with an object we see that the <code>__invoke</code> method will always be called on the same object. This means you can keep state inside properties if you want to!</p> <p>Now let's actually do something in this scope.</p> <p>The most basic thing you can do is halting the process:</p> Scope.php<pre><code>use Innmind\\Async\\Scope\\Continuation;\nuse Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\TimeContinuum\\Period;\n\nfinal class Scope\n{\n    public function __invoke(\n        mixed $_,\n        OperatingSystem $os,\n        Continuation $continuation,\n    ): Continuation {\n        $os\n            -&gt;process()\n            -&gt;halt(Period::second(1))\n            -&gt;unwrap();\n\n        return $continuation;\n    }\n}\n</code></pre> <p>This will pause the scope for a second before returning the continuation. And since by default a continuation instruct the system to call the scope once again, this means that the <code>__invoke</code> method is called every second.</p> <p>Since we only work with the scope for now, this is the same as doing:</p> <pre><code>do {\n    sleep(1);\n} while (true);\n</code></pre> <p>Now that we have a timer, we can do something else every second. For example we can fetch data via an HTTP call:</p> Scope.php<pre><code>use Innmind\\Async\\Scope\\Continuation;\nuse Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\HttpTransport\\Success;\nuse Innmind\\Http\\{\n    Request,\n    Method,\n    ProtocolVersion,\n};\nuse Innmind\\Url\\Url;\nuse Innmind\\TimeContinuum\\Period;\n\nfinal class Scope\n{\n    public function __invoke(\n        mixed $_,\n        OperatingSystem $os,\n        Continuation $continuation,\n    ): Continuation {\n        $os\n            -&gt;process()\n            -&gt;halt(Period::second(1))\n            -&gt;unwrap();\n        $users = $os\n            -&gt;remote()\n            -&gt;http()(\n                Request::of(\n                    Url::of('https://somewhere.tld/api/users'),\n                    Method::get,\n                    ProtocolVersion::v11,\n                ),\n            )\n            -&gt;match(\n                static fn(Success $success) =&gt; \\json_decode(\n                    $success-&gt;response()-&gt;body()-&gt;toString(),\n                    true,\n                ),\n                static fn(object $error) =&gt; throw new \\RuntimeException('An error occured'),\n            );\n\n        return $continuation;\n    }\n}\n</code></pre> <p>Now every second we call an api to fetch users and decode the response content. Putting everything inside the <code>__invoke</code> method can become quite verbose. But since we're in a class we can create other methods:</p> Scope.php<pre><code>use Innmind\\Async\\Scope\\Continuation;\nuse Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\HttpTransport\\Success;\nuse Innmind\\Http\\{\n    Request,\n    Method,\n    ProtocolVersion,\n};\nuse Innmind\\Url\\Url;\nuse Innmind\\TimeContinuum\\Period;\n\nfinal class Scope\n{\n    public function __invoke(\n        mixed $_,\n        OperatingSystem $os,\n        Continuation $continuation,\n    ): Continuation {\n        $users = $this-&gt;fetch($os);\n\n        return $continuation;\n    }\n\n    /**\n     * @return list&lt;string&gt;\n     */\n    private function fetch(OperatingSystem $os): array\n    {\n        $os\n            -&gt;process()\n            -&gt;halt(Period::second(1))\n            -&gt;unwrap();\n        $users = $os\n            -&gt;remote()\n            -&gt;http()(\n                Request::of(\n                    Url::of('https://somewhere.tld/api/users'),\n                    Method::get,\n                    ProtocolVersion::v11,\n                ),\n            )\n            -&gt;match(\n                static fn(Success $success) =&gt; \\json_decode(\n                    $success-&gt;response()-&gt;body()-&gt;toString(),\n                    true,\n                ),\n                static fn(object $error) =&gt; throw new \\RuntimeException('An error occured'),\n            );\n    }\n}\n</code></pre> <p>We'll see in the next chapter how to run tasks for each of these users.</p> <p>Tip</p> <p>You should explore the other APIs provided by the operating system.</p>"},{"location":"getting-started/task/","title":"Create a task","text":"<p>Let's build a simple task that looks in a database if a user exists and if not inserts it.</p> Task.php<pre><code>use Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\Url\\Url;\nuse Formal\\AccessLayer\\Query\\{\n    SQL,\n    Parameter,\n};\n\nfinal class Task\n{\n    public function __construct(\n        private string $user,\n    ) {\n    }\n\n    public function __invoke(OperatingSystem $os): void\n    {\n        $database = $os\n            -&gt;remote()\n            -&gt;sql(Url::of('mysql://user:password@127.0.0.1/database'));\n\n        $existing = $database(\n            SQL::of('SELECT * FROM users WHERE name = ?')-&gt;with(Parameter::of(\n                $this-&gt;user,\n            )),\n        );\n\n        if (!$existing-&gt;empty()) {\n            return;\n        }\n\n        $database(\n            SQL::of('INSERT INTO users (name) VALUES (?)')-&gt;with(Parameter::of(\n                $this-&gt;user,\n            )),\n        );\n    }\n}\n</code></pre> <p>You can now schedule your tasks:</p> Scope.php<pre><code>use Innmind\\Async\\Scope\\Continuation;\nuse Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\Immutable\\Sequence;\n\nfinal class Scope\n{\n    public function __invoke(\n        mixed $_,\n        OperatingSystem $os,\n        Continuation $continuation,\n    ): Continuation {\n        $users = $this-&gt;fetch($os);\n\n        return $continuation\n            -&gt;schedule(\n                Sequence::of(...$users)\n                    -&gt;map(static fn(string $user) =&gt; new Task($user)),\n            )\n            -&gt;finish();\n    }\n\n    /**\n     * @return list&lt;string&gt;\n     */\n    private function fetch(OperatingSystem $os): array\n    {\n        // see previous chapter\n    }\n}\n</code></pre>"},{"location":"preface/philosophy/","title":"Philosophy","text":"<p>Usually you'll want to use asynchronous code to improve the performance of your application. Async allows to fix IO performance. When doing IO (network calls and such) a good amount of time is spent waiting for the network to respond. Instead of waiting, async allows to do other things.</p> <p>This means you'll try to fix problems in an existing codebase.</p> <p>The goal of this package is to allow you to try running your existing synchronous code asynchronously without changing your implementation. This has 3 big advantages:</p> <ul> <li>you can experiment with async with your real code (instead of a proof of concept)</li> <li>you can go back if the async experiment isn't conclusive (1)</li> <li>you can run your code asynchronously and test it synchronously (2)</li> </ul> <ol> <li>Thus being more cost effective for your company.</li> <li>Which is usually a major pain point of async code.</li> </ol> <p>Unlike other async packages, instead of trying to duplicate the PHP functions in order to make then run asynchronously, this package rely on higher level abstractions. This helps reduce the amount of code necessary to make this package possible and consequently reduce the maintainability cost.</p>"},{"location":"preface/philosophy/#abstraction","title":"Abstraction","text":"<p>This package relies on the <code>innmind/operating-system</code> abstraction. It offers all the APIs that could benefit from being run asynchronously.</p> <p>Since all these APIs are accessed through a single object it offers a simple way to move a code from synchronous to asynchronous.</p> <p>The APIs concerned are:</p> <ul> <li>halting the process (aka an abstraction on top of <code>sleep</code>)</li> <li>sockets (HTTP, SQL, etc...)</li> <li>files</li> <li>processes</li> </ul> <p>By focusing on this abstraction as the central point to make a code run asynchronously brings another advantage. Any abstraction built on top of it makes it automatically async compatible. No need to use differents ecosystems (sync vs async).</p> <p>All this is completely transparent thanks to a lower level abstraction: Monads.</p>"},{"location":"preface/philosophy/#monads","title":"Monads","text":"<p>Monads are data structures coming from functional programming. They help solve different use cases. But the common point between all of them is that you describe what you want to do and not how to do it. It's this particular point that allows a system to inject logic on the how part to make the code run asynchronously. Without you being aware of it.</p> <p>The other big advantage of monads is their great composability. Because you only control what you want to do you can safely build abstractions upon abstractions without breaking the sync (or async) nature of the code.</p> <p>All the Innmind ecosystem rely of the monads provided by <code>innmind/immutable</code>.</p>"},{"location":"preface/philosophy/#pooling-suspensions","title":"Pooling suspensions","text":"<p>The use of the operating system abstraction in the end describe only 2 ways a code should be suspended: (1)</p> <ol> <li> <p>aka instruct to do something else while waiting.</p> </li> <li> <p>waiting X amount of time</p> </li> <li>watching for <code>resource</code>s to be ready (to read/write)</li> </ol> <p>The goal of pooling these suspensions is to determine the shortest amount of time the process really need to wait before it can again do something.</p>"},{"location":"preface/philosophy/#mapreduce","title":"MapReduce","text":"<p>MapReduce is a pattern with 2 components: Map and Reduce.</p> <ul> <li>A Map describes tasks that can be safely done concurrently to produce a result.</li> <li>A Reduce describes the way to aggregate the result of multiple tasks to a new result.</li> </ul> <p>This pattern is great because it's simple to grasp and is composable. Indeed a Map operation could itself use the MapReduce pattern to compute its value.</p> <p>This package is designed around this pattern, even though it uses a different terminology. It's composed of:</p> <ul> <li>a Scope acting as a Reduce<ul> <li>it creates tasks</li> <li>it computes a carried value</li> </ul> </li> <li>a Task acting as a Map<ul> <li>it computes a value that is fed back to the scope</li> </ul> </li> </ul>"},{"location":"preface/terminology/","title":"Terminology","text":""},{"location":"preface/terminology/#scheduler","title":"Scheduler","text":"<p>A <code>Scheduler</code> is the object responsible to coordonate the execution of a Scope and the Tasks it schedule.</p> <p>When trying to execute the scope and the tasks it will look for why them have been suspended. A scope or the tasks can be suspended when asking for the process to halt or watching for IO (files or sockets). These suspensions happen through the use of <code>innmind/operating-system</code>.</p> <p>In order to create a scheduler you need an instance of this operating system. By default this abstraction is synchronous. It's the job of the scheduler to create copies of this operating system object and pass them to the scope and tasks.</p>"},{"location":"preface/terminology/#scope","title":"Scope","text":"<p>A Scope is a function, run asynchronously, responsible to scheduling new asynchronous Tasks. It can do so indefinitively, the default behaviour, or choose to either stop and let the tasks finish or ask to be called again once a task result is available.</p> <p>The scope is also responsible to carry a value. Each time the scope is called it has access to the last carried value and has the possibility to change its value for the next call.</p> <p>The scope is run asynchronously because it will usually be the place you'll watch for a socket server to accept new connections and schedule tasks to handle these connections. Or a more simpler case it to build it as a timer that will shedule tasks every X amount of time.</p>"},{"location":"preface/terminology/#task","title":"Task","text":"<p>A Task is a function that must accept an instance of the operating system. As described above, it's thanks to this object that the function can run asynchronously.</p> <p>If a function never uses this operating system object, then it cannot run asynchronously.</p> <p>Like any other function it can return any value. When it does, the value will be made available to the scope the next time it's called.</p>"},{"location":"preface/terminology/#carried-value","title":"Carried value","text":"<p>A carried value can be any PHP variable. This value is passed to the Scope each time this function is called, and can change it for the next call.</p> <p>When the scope decides to finish running, the Scheduler will return the last value specified by the scope.</p> <p>You can use this value to gather the tasks results, compute a new value or print to the console.</p>"},{"location":"scheduler/config/","title":"Config","text":""},{"location":"scheduler/config/#limit-tasks-concurrency","title":"Limit tasks concurrency","text":"<p>By default all the tasks scheduled by a scope will be started immediately. But depending on the number you'll schedule this can take a lot of resources. To avoid the process taking too much RAM you can limit the number of tasks being run at a point in time</p> <pre><code>Scheduler::of($os)\n    -&gt;limitConcurrencyTo($size)\n    -&gt;sink(null)\n    -&gt;with(new Scope);\n</code></pre> <p><code>$size</code> can be any int above <code>2</code>. As soon a task finished it will pick a new one from the previously scheduled ones.</p> Info <p>As a point of reference, a simple script sheduling 100k tasks that halt the process for 10s will take 1.9Go of RAM (1M tasks will use 19Go).</p>"},{"location":"scopes/lifecycle/","title":"Lifecycle","text":""},{"location":"scopes/lifecycle/#restart-the-scope","title":"Restart the scope","text":"<p>By default the <code>$continuation</code> object that the scope needs to return is configured to tell the scheduler to call the scope once again. This is why be default the scheduler runs an infinite loop.</p> <p>When you return a continuation with scheduled tasks, the scheduler will start these tasks immediately and call the scope once again.</p> <p>This means that if your scope never waits on anything (1) before scheduling tasks you'll enter in a runaway situation. New tasks will keep piling on and the scheduler will never resume the suspended tasks.</p> <ol> <li>Either by halting the process or watching for sockets/files.</li> </ol> <p>You must always wait before scheduling new tasks and restarting the scope, even if it's halting the process for 1 microsend.</p>"},{"location":"scopes/lifecycle/#carry-a-value","title":"Carry a value","text":"<p>Since a scope acts as a reducer, it can keep track of a carried value that will be returned by the scheduler once the scope finishes or terminate.</p> Scope.php<pre><code>final class Scope\n{\n    public function __invoke(\n        mixed $carriedValue, // &lt;-- this is the value\n        OperatingSystem $os,\n        Continuation $continuation,\n    ): Continuation {\n        return $continuation;\n    }\n}\n</code></pre> <p>Each time the scope is called it receives the carried value from the previous call. On the first call it will receive the value passed as argument to <code>$scheduler-&gt;sink($carriedValue)</code>.</p> <p>You can change the carried value for the next call via <code>$continuation-&gt;carryWith($newValue)</code>;</p>"},{"location":"scopes/lifecycle/#run-tasks-in-the-background","title":"Run tasks in the background","text":"<p>If you want to run multiple tasks asynchronously but you don't care about there results, you need to tell the scheduler to not call the scope after scheduling the tasks.</p> Scope.php<pre><code>final class Scope\n{\n    public function __invoke(\n        $_,\n        OperatingSystem $os,\n        Continuation $continuation,\n    ): Continuation {\n        return $continuation\n            -&gt;schedule($tasks)\n            -&gt;finish();\n    }\n}\n</code></pre>"},{"location":"scopes/lifecycle/#wait-to-start-tasks","title":"Wait to start tasks","text":"<p>In most cases your scope will wait for some external event before scheduling a new task. Such event can be receiving an incoming connection on a socket:</p> <pre><code>use Innmind\\Url\\Authority\\Port;\nuse Innmind\\IO\\Sockets\\{\n    Servers\\Server,\n    Internet\\Transport,\n};\nuse Innmind\\IP\\IPv4;\nuse Innmind\\TimeContinuum\\Period;\n\nfinal class Scope\n{\n    private ?Server $server = null;\n\n    public function __invoke(\n        $_,\n        OperatingSystem $os,\n        Continuation $continuation,\n    ): Continuation {\n        $server = $this-&gt;server ??= $os\n            -&gt;ports()\n            -&gt;open(Transport::tcp(), IPv4::localhost(), Port::of(8080))\n            -&gt;unwrap();\n        $tasks = $server\n            -&gt;timeoutAfter(Period::second(1))\n            -&gt;accept()\n            -&gt;map(static fn($client) =&gt; new Task($client))\n            -&gt;maybe()\n            -&gt;toSequence();\n\n        return $continuation-&gt;schedule($tasks);\n    }\n}\n</code></pre> <p>This will look for an incoming connection every second.</p> <p>Even though we wait for an incoming connection it doesn't block other tasks because the scope itself is run asynchronously.</p>"},{"location":"scopes/lifecycle/#wait-for-tasks-results","title":"Wait for tasks results","text":"<p>Once you've scheduled all your tasks, you can tell the scheduler to call the scope only when tasks results are available. You can do that with the <code>$continuation-&gt;wakeOnResult()</code> method.</p> Scope.php<pre><code>use Innmind\\Immutable\\Sequence;\n\nfinal class Scope\n{\n    private bool $scheduled;\n\n    /**\n     * @param Sequence&lt;mixed&gt; $results\n     */\n    public function __invoke(\n        $_,\n        OperatingSystem $os,\n        Continuation $continuation,\n        Sequence $results,\n    ): Continuation {\n        if (!$this-&gt;scheduled) {\n            $this-&gt;scheduled = true,\n\n            return $continuation\n                -&gt;schedule($tasks)\n                -&gt;wakeOnResult();\n        }\n\n        doSomething($results);\n\n        return $continuation-&gt;wakeOnResult();\n    }\n}\n</code></pre> <p>Beware, not all results will be available at once. The scope may be called multiple times.</p>"},{"location":"scopes/lifecycle/#terminate-the-tasks","title":"Terminate the tasks","text":"<p>If for some reason you need to cancel all the scheduled tasks you can do it with <code>$continuation-&gt;terminate()</code>. This will make sure the scope is never called again, send a signal to each task and wait for them to stop.</p> <p>When all tasks finished, the scheduler will return the last carried value.</p> Scope.php<pre><code>final class Scope\n{\n    public function __invoke(\n        $_,\n        OperatingSystem $os,\n        Continuation $continuation,\n    ): Continuation {\n        return $continuation-&gt;terminate();\n    }\n}\n</code></pre>"},{"location":"scopes/strategies/race/","title":"Race for a result","text":"SchedulerScope <pre><code>use Innmind\\Async\\Scheduler;\nuse Innmind\\OperatingSystem\\Factory;\n\n$result = Scheduler::of(Factory::build())\n    -&gt;sink(null)\n    -&gt;with(new Scope);\n$result === 'foo'; // true\n</code></pre> <p>This is always <code>foo</code> because it's the task that waits the less.</p> <pre><code>use Innmind\\Async\\Scope\\Continuation;\nuse Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\TimeContinuum\\Period;\nuse Innmind\\Immutable\\Sequence;\n\nfinal class Scope\n{\n    private bool $scheduled;\n\n    public function __invoke(\n        array $results,\n        OperatingSystem $os,\n        Continuation $continuation,\n        Sequence $newResults,\n    ): Continuation {\n        if (!$this-&gt;scheduled) {\n            $this-&gt;scheduled = true;\n\n            return $continuation\n                -&gt;schedule(Sequence::of(\n                    static fn($os) =&gt; $os\n                        -&gt;process()\n                        -&gt;halt(Period::second(2))\n                        -&gt;map(static fn() =&gt; 'bar')\n                        -&gt;unwrap(),\n                    static fn($os) =&gt; $os\n                        -&gt;process()\n                        -&gt;halt(Period::second(1))\n                        -&gt;map(static fn() =&gt; 'foo')\n                        -&gt;unwrap(),\n                ))\n                -&gt;wakeOnResult();\n        }\n\n        return $results-&gt;first()-&gt;match(\n            static fn($value) =&gt; $continuation\n                -&gt;carryWith($value)\n                -&gt;finish(),\n            static fn() =&gt; $continuation-&gt;wakeOnResult(),\n        );\n    }\n}\n</code></pre>"},{"location":"scopes/strategies/results/","title":"Gather results","text":"SchedulerScope <pre><code>use Innmind\\Async\\Scheduler;\nuse Innmind\\OperatingSystem\\Factory;\n\n$results = Scheduler::of(Factory::build())\n    -&gt;sink([])\n    -&gt;with(new Scope);\n$results === ['foo' =&gt; 'bar', 'bar' =&gt; 'baz']; // true\n</code></pre> <pre><code>use Innmind\\Async\\Scope\\Continuation;\nuse Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\TimeContinuum\\Period;\nuse Innmind\\Immutable\\Sequence;\n\nfinal class Scope\n{\n    private bool $scheduled;\n\n    public function __invoke(\n        array $results,\n        OperatingSystem $os,\n        Continuation $continuation,\n        Sequence $newResults,\n    ): Continuation {\n        if (!$this-&gt;scheduled) {\n            $this-&gt;scheduled = true;\n\n            return $continuation\n                -&gt;schedule(Sequence::of(\n                    static fn($os) =&gt; [\n                        'foo' =&gt; $os\n                            -&gt;process()\n                            -&gt;halt(Period::second(1))\n                            -&gt;map(static fn() =&gt; 'bar')\n                            -&gt;unwrap(),\n                    ],\n                    static fn($os) =&gt; [\n                        'bar' =&gt; $os\n                            -&gt;process()\n                            -&gt;halt(Period::second(2))\n                            -&gt;map(static fn() =&gt; 'baz')\n                            -&gt;unwrap(),\n                    ],\n                ))\n                -&gt;wakeOnResult();\n        }\n\n        return $continuation\n            -&gt;carryWith(\\array_merge(\n                $results,\n                ...$newResults-&gt;toList(),\n            ))\n            -&gt;wakeOnResult();\n    }\n}\n</code></pre>"},{"location":"tasks/discard-result/","title":"Discard result","text":"<p>When a task finishes the returned value (1) will be sent to the scope the next time it's called. But if you don't need to handle the result value this adds an overhead as the results are collected and the scope needs to be called.</p> <ol> <li>Even if it's <code>null</code>.</li> </ol> <p>You can avoid this overhead by returning a special object that tells the scheduler to ignore the value.</p> Task.php<pre><code>use Innmind\\Async\\Task\\Discard;\nuse Innmind\\OperatingSystem\\OperatingSystem;\n\nfinal class Task\n{\n    public function __invoke(OperatingSystem $os): Discard\n    {\n        // do something\n\n        return Discard::result;\n    }\n}\n</code></pre> <p>Or if you don't want your task to be aware of that but want this logic to be held by your scope it's as simple as:</p> <pre><code>use Innmind\\Async\\{\n    Scope\\Continuation,\n    Task\\Discard,\n};\nuse Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\Immutable\\Sequence;\n\nfinal class Scope\n{\n    public function __invoke(\n        $_,\n        OperatingSystem $os,\n        Continuation $continuation,\n    ): Continuation {\n        return $continuation-&gt;schedule(Sequence::of(\n            Discard::result(new Task),\n        ));\n    }\n}\n</code></pre>"},{"location":"tasks/graceful-shutdown/","title":"Gracefully shutdown","text":"<p>Since a task is a function that can be run synchronously or asynchronously, it uses the same mechanism to know that it needs to gracefully stop what it's doing.</p> <p>This mechanism is process signals.</p> Task.php<pre><code>use Innmind\\OperatingSystem\\OperatingSystem;\nuse Innmind\\Signals\\Signal;\n\nfinal class Task\n{\n    public function __invoke(OperatingSystem $os)\n    {\n        $signaled = false;\n        $os\n            -&gt;process()\n            -&gt;signals()\n            -&gt;listen(Signal::terminate, function() use (&amp;$signaled) {\n                $signaled = true;\n            });\n\n        while (!$signaled) {\n            // do something\n        }\n    }\n}\n</code></pre> <p>The <code>$signaled</code> variable will be flipped in 2 cases:</p> <ul> <li>the PHP process receives the signal (that will be dispatched to all tasks that listened to it)</li> <li>the scope calls <code>$continuation-&gt;terminate()</code></li> </ul> <p>If the scope asks to terminate then it will send the signal to all tasks. This means that if you call this method in your scope you should add a listener to all your tasks otherwise the system may never terminate.</p>"}]}